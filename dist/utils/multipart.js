// Generated by CoffeeScript 1.10.0

/* jshint node:true */


/* jshint -W097 */

(function() {
  'use strict';
  var MultipartParser, Promise, errors, getObjectStream, retsParsing, through2;

  MultipartParser = require('formidable/lib/multipart_parser').MultipartParser;

  Promise = require('bluebird');

  through2 = require('through2');

  retsParsing = require('./retsParsing');

  errors = require('./errors');

  getObjectStream = function(headerInfo, stream, handler) {
    return new Promise(function(resolve, reject) {
      var bodyStream, done, flush, flushed, handleEnd, handleError, headerField, headerValue, headers, interceptor, multipartBoundary, objectStream, objectStreamDone, parser, partDone, ref, ref1, streamError;
      multipartBoundary = (ref = headerInfo.contentType.match(/boundary="[^"]+"/ig)) != null ? ref[0].slice('boundary="'.length, -1) : void 0;
      if (!multipartBoundary) {
        multipartBoundary = (ref1 = headerInfo.contentType.match(/boundary=[^;]+/ig)) != null ? ref1[0].slice('boundary='.length) : void 0;
      }
      if (!multipartBoundary) {
        throw new errors.RetsProcessingError('getObject', 'Could not find multipart boundary', headerInfo);
      }
      parser = new MultipartParser();
      objectStream = through2.obj();
      objectStreamDone = false;
      headerField = '';
      headerValue = '';
      headers = [];
      bodyStream = null;
      streamError = null;
      done = false;
      partDone = false;
      flushed = false;
      objectStream.on('end', function() {
        return objectStreamDone = true;
      });
      handleError = function(err) {
        if (bodyStream) {
          bodyStream.emit('error', err);
          bodyStream.end();
          bodyStream = null;
        }
        if (objectStreamDone) {
          return;
        }
        if (!err.error || !err.headerInfo) {
          err = {
            error: err
          };
        }
        return objectStream.write(err);
      };
      handleEnd = function() {
        if (done && partDone && flushed && !objectStreamDone) {
          return objectStream.end();
        }
      };
      parser.onPartBegin = function() {
        var object;
        object = {
          buffer: null,
          error: null
        };
        headerField = '';
        headerValue = '';
        headers = [];
        return partDone = false;
      };
      parser.onHeaderField = function(b, start, end) {
        return headerField += b.toString('utf8', start, end);
      };
      parser.onHeaderValue = function(b, start, end) {
        return headerValue += b.toString('utf8', start, end);
      };
      parser.onHeaderEnd = (function(_this) {
        return function() {
          headers.push(headerField);
          headers.push(headerValue);
          headerField = '';
          return headerValue = '';
        };
      })(this);
      parser.onHeadersEnd = function() {
        var bodyStreamDone;
        bodyStream = through2();
        bodyStreamDone = false;
        bodyStream.on('end', function() {
          return bodyStreamDone = true;
        });
        handler(headers, bodyStream).then(function(object) {
          if (!objectStreamDone) {
            return objectStream.write(object);
          }
        })["catch"](function(err) {
          return handleError(errors.ensureRetsError('getObject', err, headers));
        }).then(function() {
          partDone = true;
          return handleEnd();
        });
        parser.onPartData = function(b, start, end) {
          if (!bodyStreamDone) {
            return bodyStream.write(b.slice(start, end));
          }
        };
        return parser.onPartEnd = function() {
          if (!bodyStreamDone) {
            bodyStream.end();
          }
          return bodyStream = null;
        };
      };
      parser.onEnd = function() {
        if (done) {
          return;
        }
        return done = true;
      };
      parser.initWithBoundary(multipartBoundary);
      stream.on('error', function(err) {
        return streamError = err;
      });
      interceptor = function(chunk, encoding, callback) {
        parser.write(chunk);
        return callback();
      };
      flush = function(callback) {
        var err;
        err = parser.end();
        if (err) {
          handleError(new errors.RetsProcessingError('getObject', "Unexpected end of data: " + (errors.getErrorMessage(err)), headerInfo));
        }
        flushed = true;
        return handleEnd();
      };
      stream.pipe(through2(interceptor, flush));
      return resolve(objectStream);
    });
  };

  module.exports.getObjectStream = getObjectStream;

}).call(this);
